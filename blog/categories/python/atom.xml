<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Hrvoje's Blog]]></title>
  <link href="https://blog.hrvoje.org/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://blog.hrvoje.org/"/>
  <updated>2018-06-01T15:54:51+02:00</updated>
  <id>https://blog.hrvoje.org/</id>
  <author>
    <name><![CDATA[Hrvoje]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My Friend's 2048 Version]]></title>
    <link href="https://blog.hrvoje.org/blog/2014/09/27/my-friends-ultra-short-2048/"/>
    <updated>2014-09-27T16:37:58+02:00</updated>
    <id>https://blog.hrvoje.org/blog/2014/09/27/my-friends-ultra-short-2048</id>
    <content type="html"><![CDATA[<p>Recently I tried implementing a cool game called 2048 in Python and make it as short as possible. Thinking I did a decent job, I challenged a friend to give it a go. Blown away how much shorter it turned out to be, all I can say is - kudos to Veky.</p>

<!--more-->

<p>&#8220;`python Veky’s very short 2048</p>

<p>import random as R,tkinter as T
def M(n,q=lambda m:list(map(list,zip(<em>m[::-1]))),u={“key”:bool,”reverse”:1}):
 m=b
 for _ in range(4-n):m=q(m)
 for r in m:
  r.sort(<strong>u)
  for j in range(3):
   if r[j+1]==r[j]:r[j:j+2]=2*r[j],0
  r.sort(</strong>u)
 for _ in range(n):m=q(m)
 return m</em>(m!=b)
def A(q=8<em>*8-1):
 k,l=R.choice([divmod(i,4)for i,j in enumerate(sum(b,[]))if not j])
 b[k][l]=R.choice((2,2,4))
 for l,d in zip(L,sum(b,[])):l.config(text=d or’‘,bg=’#’+format(q-d</em>999,”06x”))
def K(e):
 c=M(dict(Left=0,Up=1,Right=2,Down=3)[e.keysym])
 if c:b[:]=c;A()
 any(map(M,F))or[x.config(bg=’red’,text=’<E2>&lt;98&gt;<B9>&#8216;)for x in L]
F=(0,1,2,3);b,t=[4*[0]for _ in F],T.Tk();t.grid()
L=[T.Button(t,height=1,width=3,font=(&#8220;Helvetica&#8221;,24))for _ in 4*F]
[L[i*4+j].grid(row=i,column=j)for i in F for j in F]
A();t.bind(&#8217;<Key>&#8216;,K);t.mainloop()</Key></B9></E2></p>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Simple 2048 Clone in Python]]></title>
    <link href="https://blog.hrvoje.org/blog/2014/09/20/a-simple-2048-clone-in-python/"/>
    <updated>2014-09-20T01:11:35+02:00</updated>
    <id>https://blog.hrvoje.org/blog/2014/09/20/a-simple-2048-clone-in-python</id>
    <content type="html"><![CDATA[<p>Every now and then a viral game shows up. It is difficult to name a particular quality which makes a game popular, but most people would probably describe it as <em>addictive</em>. 2048 is just that, despite its remarkable simplicity.</p>

<p>Soon, I started wondering how many lines of code would it take to write it and what are the bare essentials of the game, and tried writing my own version. To keep things short, movements are implemented in a single direction only. For the rest of the moves to work you have to rotate the matrix a few times first, perform the move and rotate it some more to return to your starting point. Not ideal, but simple it is. Game over detect simply checks if movement in any direction affects the board.</p>

<p>Tile creation needed to be short, so a list of zero-valued matrix elements’ coordinates was made, one picked out at random and a 2 or 4 placed there. To color the backgrounds differently, its background color is derived from its value. A dictionary could have been used as well, but it would be slightly longer.</p>

<p>That’s pretty much it - no score, no menu, no restart, no keypress error handling… just the bare essentials, but - it works. And it’s kind of fun, too!</p>

<p><code>python Short attempt with Tkinter
import random,Tkinter
def shift(c): return list([i for i in c if i&gt;0] + [0]*c.count(0))
def sms(l):
        l=shift(l)
        for i in range(len(l)-1):
                if l[i+1]==l[i]: l[i], l[i+1] = 2*l[i], 0
        return shift(l)
class igra(Tkinter.Tk):
        b = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]
        def __init__(self,parent):
                Tkinter.Tk.__init__(self,parent)
                self.parent = parent
                self.grid()
                self.bl = [Tkinter.Button(self, height=2, width=4, state=Tkinter.DISABLED, font=("Helvetica", 24)) for i in range(16)]
                for i in range(16): self.bl[i].grid(row=i//4, column=i%4)
                self.dodaj_novu()
                self.bind_all('&lt;Key&gt;', self.key)
                self.mainloop()
        def rot(self): self.b = list(map(list, zip(*self.b[::-1])))
        def move(self, n):
                diff = self.b[:]
                for i in range(n): self.rot()
                for i in range(4): self.b[i] = sms(self.b[i])
                for i in range(4-n): self.rot()
                return 1 if self.b != diff else 0
        def dodaj_novu(self):
                k = [(i//4, i%4) for i,j in enumerate(sum(self.b, [])) if j == 0][random.randint(0, sum(self.b, []).count(0)-1)]
                self.b[k[0]][k[1]] = random.randint(1,2)*2
                for i in range(16):
                        d = self.b[i//4][i%4]
                        self.bl[i].config(text=d if d else ' ', bg='#%06x'% ((2**24-1) - (d*1500) ))
        def key(self, event):
                direction={'Left': 0, 'Down': 1, 'Right': 2, 'Up': 3}
                if self.move(direction[event.keysym]): self.dodaj_novu()
                p = self.b[:]
                for i in range(4):
                        self.move(i)
                        if self.b != p:
                                self.b = p[:]
                                return
                for i in range(16): self.bl[i].config(bg='red', text=':(')
a = igra(None)
</code></p>

<p>…and it looks like this:</p>

<p><img class="center" src="/images/2048.png"></p>
]]></content>
  </entry>
  
</feed>
